这题我是用从左到右一次遍历字符串做的

curPalindromeLens数组保存在p点上以p为右边界的所有回文长度。
当i=p+1时，对于curPalindromeLens数组的每一个palindromelen，如果
 s[i] == s[i-palindromelen-2]
那么以p+1为右边界的回文存在，长度为palindromelen+2，把它加到p+1点的回文长度数组
同时如果s[i]=s[i-1]，那么把连续的字符串长度加到回文长度数组
否则如果s[i]=s[i-2]，那么把长度为3的回文加到回文长度数组

初始状态p=0, curPalindromeLens={1}，只有一个包含一个字符的回文串。

遍历完s，得到中间最大的回文长度就可以了

执行结果：
通过
显示详情
添加备注

执行用时：
0 ms
, 在所有 Go 提交中击败了
100.00%
的用户

内存消耗：
2.6 MB
, 在所有 Go 提交中击败了
100.00%
的用户